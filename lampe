#!/bin/bash
# lampe by AndrÃ© Klausnitzer, CC0
# interactive bash script to control your Philips Hue lights

version="1.1.1"

# XXX   not used
readKey() {
    # Wait for first char
    if read -s -n 1 _KEY; then
      	# Read rest of chars
      	while read -s -N 1 -t 0.001 ; do
      		_KEY+="${REPLY}"
      	done
    fi
}

# defaults: can be redefined in ~/.lamperc
declare _SELECTED_LAMP=1
tmdCsvFile="$HOME/public_html/tm/tm_720.csv"

checkKey() {
	case $1 in
		# $'\e[A' |
		"w")
			_UP=1
		;;
		# $'\e[B' |
		"s")
			_DOWN=1
		;;
		# $'\e[C' |
		"d")
			_RIGHT=1
		;;
		# $'\e[D' |
		"a")
			_LEFT=1
		;;
		"q")
			# hue
			_Q=1
		;;
		"e")
			# hue
			_E=1
		;;
		"y")
			# on
			_Y=1
		;;
		"n")
			# off
			_N=1
		;;
		"h")
			# help
			_H=1
		;;
		"z")
			# color-selection with zenity
			_Z=1
		;;
		"i")
			# info: do not send new, but receive light state
			_I=1
		;;
		"I")
			# info: receive state of all lights
			_II=1
		;;
		"r")
			# random
			if [[ "$LAMPE_R" == 1 ]] ; then
				# stop
				LAMPE_R=0 
				rm "/tmp/lampeSequenceR$_SELECTED_LAMP" 2> /dev/null
				
				# debug
				# echo "stop random"
			else
				# start
				LAMPE_R=1
				
				# debug
				# echo "start random"
			fi
		;;
		"b")
			# blink
			if [[ "$LAMPE_B" == 1 ]] ; then
				# stop
				LAMPE_B=0 
				rm "/tmp/lampeSequenceB$_SELECTED_LAMP" 2> /dev/null
			else
				# start
				LAMPE_B=1
			fi
		;;
		"A")
			# alert select
			_A=1
		;;
		"Q")
			# quit
			_QQ=1
		;;
		"S")
			# save current light-setting as new user default
			_S=1
		;;
		"L")
			# load light-setting from saved user default
			_L=1
		;;
		"m")
			# mood light
			if [[ "$LAMPE_M" == 1 ]] ; then
				# stop
				LAMPE_M=0 
				rm "/tmp/lampeSequenceM$_SELECTED_LAMP" 2> /dev/null
			else
				# start
				LAMPE_M=1 
			fi
		;;
	esac
}

readAKey() {
	# readKey
	read -s -n 1 _KEY

	case $_KEY in
		[1-9])
			# select light
			printMainScreen "$_KEY"
			_SELECTED_LAMP=$_KEY
			readLightNumber "$_KEY"
		;;
		*)
			checkKey "$_KEY"
		;;
	esac
}

readLightNumber() {
	local number=$_KEY
	
	# debug
	# echo "number = '$number'"
	
	read -s -n 1 _NEXT_KEY
	case $_NEXT_KEY in
		[0-9])
			number=$number$_NEXT_KEY
		;;
		*)
			checkKey "$_NEXT_KEY"
		;;
	esac
	
	_SELECTED_LAMP=$number
	
	# debug
	# echo "_SELECTED_LAMP = '$_SELECTED_LAMP'"
}

# init brightness
declare -a _BRIGHTNESS
for (( b=1 ; b<100 ; b=b+1 )) ; do 
	_BRIGHTNESS[$b]=32
done

# init saturation
declare -a _SAT
for (( s=1 ; s<100 ; s=s+1 )) ; do 
	_SAT[$s]=192
done

# init switch
declare -a _SWITCH # on or off
for (( s=1 ; s<100 ; s=s+1 )) ; do 
	_SWITCH[$s]="true"
done

# init color
declare -a _COLOR 
for (( s=1 ; s<100 ; s=s+1 )) ; do 
	_COLOR[$s]=12000 # orange
done

moodSequence() {
	while [[ -f "/tmp/lampeSequenceM$_SELECTED_LAMP" ]] ; do
		# tmdLine=$(cat "$tmdCsvFile" | tail -n 1 | cut -f 2-3 -d',' 2> /dev/null)
		tmdLine=$(tail -n 1 < "$tmdCsvFile" | cut -f 2-3 -d',' 2> /dev/null)
		tmdInside=$(echo "$tmdLine" | cut -f 1 -d',')
		tmdOutside=$(echo "$tmdLine" | cut -f 2 -d',')
		
		local temperatureDiff=$(( tmdOutside-tmdInside ))
		local diffFactor=1
		if [[ "$temperatureDiff" -gt 0 ]] ; then
			diffFactor=4
		fi
		local hueDiff=$(( temperatureDiff*diffFactor+25750 ))
		local hue="\"hue\":$hueDiff,\"transitiontime\":30"
		curl -s -d "{$hue}" -X PUT "http://$bridgeip/api/lampe-bash/lights/$_SELECTED_LAMP/state" -m 1 > /dev/null
	
		hbReceiveLightState "$_SELECTED_LAMP"
		sleep 60
	done
}

# GPN15 preview sequence
previewRandom() {
	# debug
	# echo "random called, '$LAMPE_R'"

	local on="true" 
		# FIXME or should only be done by the main loop?
	while [[ -f "/tmp/lampeSequenceR$_SELECTED_LAMP" ]] ; do
		# debug
		# echo "do random, '$LAMPE_R'"
	
		local hue=$(( RANDOM*2 )) 
		local color="\"hue\":$hue,\"bri\":${_BRIGHTNESS[$_SELECTED_LAMP]},\"sat\":${_SAT[$_SELECTED_LAMP]},\"transitiontime\":100"
		curl -s -d "{\"on\":$on,$color}" -X PUT "http://$bridgeip/api/lampe-bash/lights/$_SELECTED_LAMP/state" -m 1 > /dev/null
	
		hbReceiveLightState "$_SELECTED_LAMP"
		sleep 10
			# FIXME or use a param for a callback?
	done
}

# blink preview sequence
previewBlink() {
	local on="true" 
	local bri="$1"
	while [[ -f "/tmp/lampeSequenceB$_SELECTED_LAMP" ]] ; do
		curl -s -d "{\"on\":$on,\"transitiontime\":0,\"bri\":$bri}" -X PUT "http://$bridgeip/api/lampe-bash/lights/$_SELECTED_LAMP/state" -m 1 > /dev/null

		sleep 1
		if [[ "$on" == "true" ]] ; then
			on="false"
		else
			on="true"
		fi
	done
}

selectAlert() {
	curl -s -d "{\"alert\":\"select\"}" -X PUT "http://$bridgeip/api/lampe-bash/lights/$_SELECTED_LAMP/state" -m 1 > /dev/null
}

setBrightness() {
	brightness=${_BRIGHTNESS[$_SELECTED_LAMP]}
	
	brightness=$((brightness+$1))
	if [ $brightness -lt 1 ] ; then
		# switch off lamp
		setSwitch 0
		brightness=0
	elif [ $brightness -gt 0 ] ; then
		# switch on lamp
		setSwitch 1
		if [ $brightness -gt 254 ] ; then
			brightness=254
		fi
	fi

	_BRIGHTNESS[$_SELECTED_LAMP]=$brightness

	# debug
	# echo -n "param = $1 "
	# echo "brightness = ${_BRIGHTNESS[$_SELECTED_LAMP]} "
} 

setSat() {
	sat=${_SAT[$_SELECTED_LAMP]}
	
	sat=$((sat+$1))
	if [ $sat -lt 1 ] ; then
		sat=1
	elif [ $sat -gt 254 ] ; then
		sat=254
	fi

	_SAT[$_SELECTED_LAMP]=$sat
}

setColor() {
	hue=${_COLOR[$_SELECTED_LAMP]}
	
	hue=$((hue+$1))
	if [ $hue -lt 1 ] ; then
		hue=65280
	elif [ $hue -gt 65280 ] ; then
		hue=1
	fi

	# debug
	# echo " $hue "

	_COLOR[$_SELECTED_LAMP]=$hue
} 

setSwitch() {
	# debug
	# echo -n $1

	if [[ "$1" == 1 ]] ; then 
		_SWITCH[$_SELECTED_LAMP]="true"
	else
		_SWITCH[$_SELECTED_LAMP]="false"
	fi
}

# get colorEscapes from colors
lColor() {
	case $1 in
		"red")
			echo -en "\e[0;31m"
		;;
		"yellow")
			echo -en "\e[0;33m"
		;;
		"green")
			echo -en "\e[0;32m"
		;;
		"blue")
			echo -en "\e[0;34m"
		;;
		"magenta")
			echo -en "\e[0;35m"
		;;
		"cyan")
			echo -en "\e[0;36m"
		;;
		"white")
			echo -en "\e[0;37m"
		;;
		"ltred")
			echo -en "\e[1;31m"
		;;
		"ltyellow")
			echo -en "\e[1;33m"
		;;
		"ltgreen")
			echo -en "\e[1;32m"
		;;
		"ltblue")
			echo -en "\e[1;34m"
		;;
		"ltmagenta")
			echo -en "\e[1;35m"
		;;
		"ltcyan")
			echo -en "\e[1;36m"
		;;
		"ltwhite")
			echo -en "\e[1;37m"
		;;
		"off")
			echo -en "\e[0m"
		;;
	esac
}

getColorByValue() {
	hue=$1

	if [ "$hue" -lt 9001 ] ; then
		# red
		colorEscape="red"
	elif [ "$hue" -gt 9000 ] && [ "$hue" -lt 19001 ] ; then
		# orange, yellow
		colorEscape="yellow"
	elif [ "$hue" -gt 19000 ] && [ "$hue" -lt 31001 ] ; then
		# green
		colorEscape="green"
	elif [ "$hue" -gt 31000 ] && [ "$hue" -lt 35001 ] ; then
		# white, green-blue, cyan
		colorEscape="cyan"
	elif [ "$hue" -gt 35000 ] && [ "$hue" -lt 48001 ] ; then
		# blue
		colorEscape="blue"
	elif [ "$hue" -gt 48000 ] && [ "$hue" -lt 63279 ] ; then
		# purple
		colorEscape="magenta"
	elif [ "$hue" -gt 63279 ] ; then
		# red
		colorEscape="red"
	fi
	echo -en "$(lColor $colorEscape)"
}

# get color by color of selected lamp
getColor() {
	# debug
	# echo " getColor._SELECTED_LAMP = $_SELECTED_LAMP"

	hue=${_COLOR[$_SELECTED_LAMP]}
	
	# debug
	# echo " getColor.hue = '$hue'"

	bold=""
	if [[ ${_SWITCH[$_SELECTED_LAMP]} == "true" ]] ; then
		bold="lt"
	fi
	if [ $hue -lt 9001 ] ; then
		# red
		colorEscape="red"
	elif [ $hue -gt 9000 ] && [ $hue -lt 19001 ] ; then
		# orange, yellow
		colorEscape="yellow"
	elif [ $hue -gt 19000 ] && [ $hue -lt 31001 ] ; then
		# green
		colorEscape="green"
	elif [ $hue -gt 31000 ] && [ $hue -lt 35001 ] ; then
		# white, green-blue, cyan
		colorEscape="cyan"
	elif [ $hue -gt 35000 ] && [ $hue -lt 48001 ] ; then
		# blue
		colorEscape="blue"
	elif [ $hue -gt 48000 ] && [ $hue -lt 63279 ] ; then
		# purple
		colorEscape="magenta"
	elif [ $hue -gt 63279 ] ; then
		# red
		colorEscape="red"
	fi
	echo -en "$(lColor $bold$colorEscape)"
}

printMainScreen() {
	local firstNumer=$1

	if [[ "$L_BLIND" == 0 ]] ; then
		currentBrightness=$((_BRIGHTNESS[_SELECTED_LAMP]/5))
		currentSat=$((_SAT[_SELECTED_LAMP]*currentBrightness/254))
		colorPosition=$((_COLOR[_SELECTED_LAMP]*currentBrightness/65279))
		if [ $colorPosition -gt 1 ] ; then
			colorPosition=$((colorPosition-1))
		fi

		# debug
		# echo "$colorPosition"
		# echo "firstNumer = '$firstNumer'"

		echo -en "    \b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b"
		if [ -n "$firstNumer" ] ; then
			echo -n "$firstNumer. "
		else
			if [ "$_SELECTED_LAMP" -lt 10 ] ; then
				echo -n " "
			fi
			echo -en "$(getColor)$_SELECTED_LAMP $(lColor ltwhite)"
		fi
		
		echo -en "[$(lColor off)"
		for (( ii=0 ; ii<currentBrightness ; ii=ii+1 )) ; do 
			colorValue=$((65279*ii/currentBrightness))
			echo -en "$(getColorByValue $colorValue)"

			if [ $ii == $colorPosition ] ; then
				if [[ -f "/tmp/lampeSequenceR$_SELECTED_LAMP" ]] ; then
					echo -en "$(getColor)R$(lColor off)"
				elif [[ -f "/tmp/lampeSequenceB$_SELECTED_LAMP" ]] ; then
					echo -en "$(getColor)B$(lColor off)"
				elif [[ -f "/tmp/lampeSequenceM$_SELECTED_LAMP" ]] ; then
					echo -en "$(getColor)M$(lColor off)"
				else
					echo -en "$(getColor)C$(lColor off)"
				fi
			else
				if [ $ii -lt $currentSat ] ; then
					echo -n "="
				else
					echo -n "-"
				fi
			fi
		done
		for (( ii=0 ; ii<50-currentBrightness ; ii=ii+1 )) ; do
			echo -n " "
		done
		echo -en "$(lColor ltwhite)]$(lColor off) "
		if [[ ${_SWITCH[$_SELECTED_LAMP]} != "true" ]] ; then
			echo -n "off "
		else
			echo -n "    "
		fi
	fi
}

# XXX   not used
toggleSwitch() {
	if [ ${_SWITCH[$_SELECTED_LAMP]} = "true" ] ; then
		setSwitch 0
	else 
		setSwitch 1
	fi
}

printHelpScreen() {
	echo ""
	echo "    1..99    LIGHT         confirm with any key"
	echo "    w, s     BRIGHTNESS    -"
	echo "    a, d     SATURATION    ="
	echo "    q, e     COLOR         C"
	echo "    y, n     SWITCH        on, off"
	echo "    z        ZENITY        choose RGB-color"
	echo "    i, I     INFO          receive (all) light state/s"
	echo "    S, L     SETTINGS      save, load user defaults"
	echo "    r        RANDOM        R: random color sequence"
	echo "    b        BLINK         B: blinking sequence"
	echo "    A        ALERT"
	echo "    m        MOOD          M: temperature difference"
	echo "                              based color sequence"
	#        [--------------------------------------------------]
	echo "    Q        QUIT"
}

lampeQuit() {
	echo -en "\n    Do you really want to quit 'lampe'? [$(lColor ltwhite)y$(lColor off)/$(lColor ltred)n$(lColor off)] "
	read doQuit
	if [[ "$doQuit" == "y" ]] || [[ "$doQuit" == "Y" ]] || [[ "$doQuit" == "" ]] ; then
		echo " $(lColor ltgreen)!$(lColor off)  bye"
		
		# cleanup and quit
		rm /tmp/lampeSequence* 2> /dev/null
		# killall lampe > /dev/null
		exit 0
	fi
}

lampeMain() {
	# initial screen
	echo -en "   [$(lColor red)=$(lColor yellow)=$(lColor green)=$(lColor cyan)=$(lColor blue)=$(lColor magenta)=$(lColor ltwhite)---LAMPE-$version---PRESS-h-FOR-HELP-----------$(lColor off)]"

	lastTime=$(date +%s%3N) # seconds + milliseconds
	while true; do
		# main loop

		# initialize keys
		_UP=0
		_DOWN=0
		_RIGHT=0
		_LEFT=0
		_Q=0
		_E=0
		_Y=0
		_N=0
		_H=0
		_Z=0
		_I=0
		_II=0
		_A=0
		_QQ=0
		_S=0
		_L=0

		readAKey

		# handle keys
		if [[ "$_UP" == 1 ]] ; then
			setBrightness 5
		elif [[ "$_DOWN" == 1 ]] ; then
			setBrightness -5
		elif [[ "$_RIGHT" == 1 ]] ; then
			setSat 10
		elif [[ "$_LEFT" == 1 ]] ; then
			setSat -10
		elif [[ "$_Q" == 1 ]] ; then
			# hue
			setColor -1000
		elif [[ "$_E" == 1 ]] ; then
			# hue
			setColor 1000
		elif [[ "$_Y" == 1 ]] ; then
			setSwitch 1
		elif [[ "$_N" == 1 ]] ; then
			setSwitch 0
		elif [[ "$_H" == 1 ]] ; then
			printHelpScreen
		elif [[ "$_Z" == 1 ]] ; then
			lampeZenityColor "$_SELECTED_LAMP"
		elif [[ "$_A" == 1 ]] ; then
			selectAlert
		elif [[ "$_QQ" == 1 ]] ; then
			lampeQuit
		elif [[ "$_S" == 1 ]] ; then
			saveLightSetting
			saveAllSettings
		elif [[ "$_L" == 1 ]] ; then
			loadLightSetting
		fi

		# FIXME is this workarround still needed?
		if [[ "${_SAT[$_SELECTED_LAMP]}" -lt 1 ]] ; then
			_SAT[$_SELECTED_LAMP]=1
		fi

		if [[ "$_I" == 1 ]] ; then
			# receive current light state
			hbReceiveLightState "$_SELECTED_LAMP" 
			# printMainScreen
		elif [[ "$_II" == 1 ]] ; then
			# receive all light states
			hbReceiveLightStates
			# printMainScreen
		else
			# send
			if [[ "$_H" == 0 ]] ; then
				# do not send new light state if help screen was shown
				hbSendLightsState
			fi
			
			# start preview sequence
			if [[ "$LAMPE_R" == 1 ]] && [[ ! -f "/tmp/lampeSequenceR$_SELECTED_LAMP" ]] ; then
				# echo
				# echo "got key to call random"
			
				touch "/tmp/lampeSequenceR$_SELECTED_LAMP" 2> /dev/null
				rm "/tmp/lampeSequenceM$_SELECTED_LAMP" 2> /dev/null
				LAMPE_M=0
				rm "/tmp/lampeSequenceB$_SELECTED_LAMP" 2> /dev/null
				LAMPE_B=0
				( previewRandom ) &
			elif [[ "$LAMPE_B" == 1 ]] && [[ ! -f "/tmp/lampeSequenceB$_SELECTED_LAMP" ]] ; then
				# debug
				# echo "main.bri = '${_BRIGHTNESS[$_SELECTED_LAMP]}'"
			
				touch "/tmp/lampeSequenceB$_SELECTED_LAMP" 2> /dev/null
				rm "/tmp/lampeSequenceM$_SELECTED_LAMP" 2> /dev/null
				LAMPE_M=0
				rm "/tmp/lampeSequenceR$_SELECTED_LAMP" 2> /dev/null
				LAMPE_R=0
				( previewBlink "${_BRIGHTNESS[$_SELECTED_LAMP]}" ) &
			elif [[ "$LAMPE_M" == 1 ]] && [[ ! -f "/tmp/lampeSequenceM$_SELECTED_LAMP" ]] ; then
				touch "/tmp/lampeSequenceM$_SELECTED_LAMP" 2> /dev/null
				rm "/tmp/lampeSequenceR$_SELECTED_LAMP" 2> /dev/null
				LAMPE_R=0
				rm "/tmp/lampeSequenceB$_SELECTED_LAMP" 2> /dev/null
				LAMPE_B=0
				( moodSequence ) &
			fi
		fi
		printMainScreen
	done
}

# send lamp state (switch and color) to Hue Bridge
hbSendLightsState() {
	color="\"hue\":${_COLOR[$_SELECTED_LAMP]},\"bri\":${_BRIGHTNESS[$_SELECTED_LAMP]},\"sat\":${_SAT[$_SELECTED_LAMP]}"
	thisTime=$(date +%s%3N)
	diffTime=$((thisTime-lastTime))
	if [ $diffTime -gt 125 ] ; then
		# only send new state every 125ms
		curl -s -d "{\"on\":${_SWITCH[$_SELECTED_LAMP]},$color}" -X PUT "http://$bridgeip/api/lampe-bash/lights/$_SELECTED_LAMP/state" -m 1 > /dev/null
		lastTime=$(date +%s%3N)
	fi
}

# evaluate floating-point expression
# taken from http://www.linuxjournal.com/content/floating-point-math-bash, 
# by Mitch Frazier
fEval() {
    local stat=0
    local result=0.0
    if [[ $# -gt 0 ]]; then
        result=$(echo "$fScale $*" | bc -q 2> /dev/null)
        stat=$?
        if [[ $stat -eq 0  &&  -z "$result" ]]; then stat=1; fi
    fi
    
    echo "$result"
    return $stat
}

# check floating-point condition
# taken from http://www.linuxjournal.com/content/floating-point-math-bash
# by Mitch Frazier
fCond() {
    local cond=0
    if [[ $# -gt 0 ]]; then
        cond=$(echo "$*" | bc -q 2> /dev/null)
        if [[ -z "$cond" ]]; then cond=0; fi
        if [[ "$cond" != 0  &&  "$cond" != 1 ]]; then cond=0; fi
    fi
    local stat=$((cond == 0))
    
    return $stat
}

# convert RGB color to HSB/HSV color
# implementation ported from python2.7 colorsys.rgb_to_hsv()
rgbToHSB() {
	fScale="scale=5;"
	r=$(fEval "$1 / 255")
	g=$(fEval "$2 / 255")
	b=$(fEval "$3 / 255")

	# debug
	# echo "r = $r"
	# echo "g = $g"
	# echo "b = $b"

	minc=$b
	if fCond "$r < $g" ; then
		if fCond "$r < $b" ; then
			minc=$r
		fi
	else
		if fCond "$g < $b" ; then
			minc=$g
		fi
	fi

	# debug
	# echo "minc = $minc"

	maxc=$b
	if fCond "$r > $g" ; then
		if fCond "$r > $b" ; then
			maxc=$r
		fi
	else
		if fCond "$g > $b" ; then
			maxc=$g
		fi
	fi

	# debug
	# echo "maxc = $maxc"

	_bri=$maxc
	if [[ "$minc" == "$maxc" ]] ; then
		_hue=0
		_sat=0
	else
		_sat=$(fEval "($maxc - $minc) / $maxc")
		rrrc=$(fEval "($maxc - $r) / ($maxc - $minc)")
		gggc=$(fEval "($maxc - $g) / ($maxc - $minc)")
		bbbc=$(fEval "($maxc - $b) / ($maxc - $minc)")
		if [ "$r" = "$maxc" ] ; then
			_hue=$(fEval "$bbbc - $gggc")

			# debug
			# echo "_hue = $_hue"
		elif [ "$g" = "$maxc" ] ; then
			_hue=$(fEval "2.0 + $rrrc - $bbbc")

			# debug
			# echo "_hue = $_hue"
		else
			_hue=$(fEval "4.0 + $gggc - $rrrc")

			# debug
			# echo "_hue = $_hue"
		fi
		_hue=$(fEval "$_hue / 6.0")

		# debug
		# echo "_hue = $_hue"
	fi

	set -f # turn off pathname expansion: *
	fScale="scale=0;"
	_hue=$(fEval "$_hue * 65535")
	_hue=$(echo "$_hue" | cut -f 1 -d.)
	_bri=$(fEval "$_bri * 255")
	_bri=$(echo "$_bri" | cut -f 1 -d.)
	_sat=$(fEval "$_sat * 255")
	_sat=$(echo "$_sat" | cut -f 1 -d.)
	set +f
}

lampeZenityColor() {
	zColor=$(zenity --color-selection --show-palette 2> /dev/null)
	rr=$(echo "$zColor" | cut -b 2-3)
	gg=$(echo "$zColor" | cut -b 6-7)
	bb=$(echo "$zColor" | cut -b 10-11)

	# convert from hex to dec
	rr=$((16#$rr))
	gg=$((16#$gg))
	bb=$((16#$bb))
	rgbToHSB $rr $gg $bb
	
	# debug
	# echo $zColor
	# echo "rr = $rr"
	# echo "gg = $gg"
	# echo "bb = $bb"
	# echo "hue = $_hue"
	# echo "bri = $_bri"
	# echo "sat = $_sat"

	if [ "$_hue" -lt 0 ] ; then
		_hue=$((_hue+65535)) # rotate hue
	fi
	_COLOR[$1]=$_hue
	if [ "$_bri" -gt 254 ] ; then
		_bri=254
	fi
	_BRIGHTNESS[$1]=$_bri
	_SAT[$1]=$_sat
}

# checks wether there is a hue bridge at given IP
hbCheck() {
	hbDescription=$(curl "http://$1/description.xml" -m 3 2> /dev/null)
	hbModel=$(echo "$hbDescription" | grep "<modelDescription>Philips hue Personal Wireless Lighting</modelDescription>")
}

# try to detect the first Hue Bridge in the LAN (ipv4 class-C networks only, can detect only one bridge)
hbDetect() {
	_BRIDGE_FOUND=false
	
	# XXX   bug#4 fixed, all subnets will be searched, but discovery will stop at the first found hue-bridge
	tmpIPsFile="/tmp/lampe$$.tmp"
	L_ips=$(ip -f inet addr show | grep "/24" | sed -r "s/inet //" | cut -f 1-4 -d. | cut -f 1 -d"/")
		# TODO support subnets other than /24, maybe all that are <= /24 (for that, it is necessary to calculate the range of IPs in the subnet)
	for L_ip in $L_ips ; do 
		# debug
		# echo "L_ip = '$L_ip'"
		
		ipByte4=$(echo "$L_ip" | cut -f 4 -d.)
		currentIpByte4=$ipByte4
		ipBytes13=$(echo "$L_ip" | cut -f 1-3 -d.)
		
		# debug
		# echo "ipByte4 = '$ipByte4', ipBytes13 = '$ipBytes13'"
		
		# ping the whole subnet in parallel and write ip-adresses to a file
		subnet="$ipBytes13."
		( for addr in $(seq 1 1 254); do ( ping -c 1 -t 3 "$subnet$addr" > /dev/null && echo "$subnet$addr" >> "$tmpIPsFile" ) & done ) > /dev/null 
	done
	
	# debug
	# cat $tmpIPsFile
	
	# check for model description
	while read nextIP ; do
		# debug
		# echo "nextIP = $nextIP"
		
		ownIP="$subnet$currentIpByte4"
		if [[ "$nextIP" != "$ownIP" ]] ; then
			hbCheck "$nextIP"
		
			# debug
			# echo "hbDescription (response) = '$hbDescription'"
			# echo "hbModel = '$hbModel'"
		
			if [ -n "$hbModel" ] ; then
				_BRIDGE_FOUND=true
				bridgeip=$nextIP
				echo "    bridge found at '$nextIP'."
				break
			fi	
		fi
	done < $tmpIPsFile
	rm $tmpIPsFile 2> /dev/null
}

hbEnterIP() {
	echo -n "    Please enter the IP of your HUE-bridge: "
	read manualIP
	hbCheck "$manualIP"
	if [ -n "$hbModel" ] ; then
		_BRIDGE_FOUND=true
		bridgeip=$manualIP
		echo "    bridge found."
	fi	
}

# this function will be called, if the configuration is valid
startLampe() {
	L_BLIND=0
	if [[ "$1" == "-z" ]] || [[ "$1" == "--zenity" ]] ; then
		# open zenity dialog to select color and quit
		_SELECTED_LAMP=$2
		lampeZenityColor "$2"
		hbSendLightsState
	elif [[ "$1" == "-b" ]] || [[ "$1" == "--blind" ]] ; then
		# blind modus: do not print main screen
		L_BLIND=1
		lampeMain
	else
		# default: interactive-mode
		lampeMain
	fi
}

hbRegisterUser() {
	echo "    Please press the $(lColor ltblue)Link-button$(lColor off) on your bridge to "
	echo -n "    register a user ... "
	while true ; do
		# try user registration every two seconds
		sleep 2
		
		hbUser=$(curl -d "{\"devicetype\": \"lampe-$version\", \"username\": \"lampe-bash\"}" "http://$bridgeip/api" -m 2 2> /dev/null)
		success=$(echo "$hbUser" | grep "success")
		
		# debug
		# echo "hbUser = $hbUser"
		
		if [ -n "$success" ] ; then
			echo -e "\n    user registered."
			break
		fi
	done
}

showHelp() {
	echo "lampe-$version by AndrÃ© Klausnitzer, CC0"
	echo "    without option (interactive)"
	echo " -b, --blind"
	echo "    blind-mode (interactive)"
	echo " -h, --help"
	echo "    show this help"
	echo " -z, --zenity [LIGHT-ID]"
	echo "    pick a RGB-color with zenity color selection (non-interactive)"
}

# receive just one light state.
hbReceiveLightState() {
	local light=$1
	hbLightState=$(curl "http://$bridgeip/api/lampe-bash/lights/$light" -m 2 2> /dev/null)
	lightState=$(echo "$hbLightState" | grep "state")
	if [ -n "$lightState" ] ; then
		# debug
		# echo "lightState[$light] = '$lightState'"
		
		# no use of JSON.sh, so that users who cannot install JSON.sh are still able to receive the
		# state of the current light
		lightSwi=$(echo "$lightState" | sed -r "s/\"on\":/;/" | cut -f 2 -d";" | cut -f 1 -d"," )
		lightBri=$(echo "$lightState" | sed -r "s/\"bri\":/;/" | cut -f 2 -d";" | cut -f 1 -d"," )
		lightHue=$(echo "$lightState" | sed -r "s/\"hue\":/;/" | cut -f 2 -d";" | cut -f 1 -d"," )
		lightSat=$(echo "$lightState" | sed -r "s/\"sat\":/;/" | cut -f 2 -d";" | cut -f 1 -d"," )
		
		# debug
		# echo "lightSwi[$light] = '$lightSwi'" 
		# echo "lightBri[$light] = '$lightBri'"
		# echo "lightHue[$light] = '$lightHue'"
		# echo "lightSat[$light] = '$lightSat'"
		
		_SWITCH[$light]=$lightSwi
		_BRIGHTNESS[$light]=$lightBri
		_COLOR[$light]=$lightHue
		_SAT[$light]=$lightSat
	fi
}

# receives all light states. received json will be parsed by using JSON.sh
hbReceiveLightStates() {
	local lightStates=""
	
	lightStates=$(curl "http://$bridgeip/api/lampe-bash/lights" -m 2 2> /dev/null)
	parsedJsonLightStates=$(echo "$lightStates" | JSON.sh -b 2> /dev/null)
	for (( light=1 ; light<51 ; light=light+1 )) ; do
		# debug
		# echo "light = $light"	
			
		lightSwi=$(echo "$parsedJsonLightStates" | grep "\"$light\",\"state\",\"on\"" | cut -f 2)
		if [[ -n "$lightSwi" ]] ; then
			_SWITCH[$light]=$lightSwi
			
			# it is assumed that for every light that has a switch the 
			# following params are availabe in the json output
			lightBri=$(echo "$parsedJsonLightStates" | grep "\"$light\",\"state\",\"bri\"" | cut -f 2)
			_BRIGHTNESS[$light]=$lightBri
		
			lightHue=$(echo "$parsedJsonLightStates" | grep "\"$light\",\"state\",\"hue\"" | cut -f 2)
			_COLOR[$light]=$lightHue
			
			lightSat=$(echo "$parsedJsonLightStates" | grep "\"$light\",\"state\",\"sat\"" | cut -f 2)
			_SAT[$light]=$lightSat
		else
			# defaults
			_SWITCH[$light]="true"
			_BRIGHTNESS[$light]=32
			_COLOR[$light]=12000
			_SAT[$light]=192
		fi
		
		# debug
		# echo "_COLOR = ${_COLOR[$light]}"
	done
}

checkDependency() {
	which "$1" 2> /dev/null 1> /dev/null
	if [[ "$?" -gt 0 ]] ; then
		echo " $(lColor ltred)?$(lColor off)  warning, '$1' is not installed"
	fi
}

# check for dependencies
checkDependency "JSON.sh"
checkDependency "zenity"

loadLightSetting() {
	if [[ -n "${SAVED_SWITCH[$_SELECTED_LAMP]}" ]] ; then
		# it is assumed that for every light that has a saved switch state 
		# there are saved values for all following params
		_SWITCH[$_SELECTED_LAMP]=${SAVED_SWITCH[$_SELECTED_LAMP]}
		_BRIGHTNESS[$_SELECTED_LAMP]=${SAVED_BRIGHTNESS[$_SELECTED_LAMP]}
		_COLOR[$_SELECTED_LAMP]=${SAVED_COLOR[$_SELECTED_LAMP]}
		_SAT[$_SELECTED_LAMP]=${SAVED_SAT[$_SELECTED_LAMP]}
	fi
}

saveLightSetting() {
	SAVED_SWITCH[$_SELECTED_LAMP]=${_SWITCH[$_SELECTED_LAMP]}
	SAVED_BRIGHTNESS[$_SELECTED_LAMP]=${_BRIGHTNESS[$_SELECTED_LAMP]}
	SAVED_COLOR[$_SELECTED_LAMP]=${_COLOR[$_SELECTED_LAMP]}
	SAVED_SAT[$_SELECTED_LAMP]=${_SAT[$_SELECTED_LAMP]}
}

saveAllSettings() {
	mkdir -p ~/.config/lampe 2> /dev/null
	echo "" > ~/.config/lampe/light-settings
	for (( light=1 ; light<51 ; light=light+1 )) ; do
		if [[ -n "${SAVED_SWITCH[$light]}" ]] ; then			
			# it is assumed that for every light that has a saved switch state 
			# there are saved values for all following params
			{ echo "_SWITCH[$light]=\"${SAVED_SWITCH[$light]}\"" ; 
			echo "SAVED_SWITCH[$light]=\"${SAVED_SWITCH[$light]}\"" ; 
			echo "_BRIGHTNESS[$light]=\"${SAVED_BRIGHTNESS[$light]}\"" ; 
			echo "SAVED_BRIGHTNESS[$light]=\"${SAVED_BRIGHTNESS[$light]}\"" ; 
			echo "_COLOR[$light]=\"${SAVED_COLOR[$light]}\"" ; 
			echo "SAVED_COLOR[$light]=\"${SAVED_COLOR[$light]}\"" ; 
			echo "_SAT[$light]=\"${SAVED_SAT[$light]}\"" ; 
			echo "SAVED_SAT[$light]=\"${SAVED_SAT[$light]}\"" ; } >> ~/.config/lampe/light-settings
		fi
	done
}

if [[ "$1" == "-h" ]] || [[ "$1" == "--help" ]] ; then
	# show help and quit
	showHelp
elif [[ -f ~/.lamperc ]] ; then
	# read configuration
	source ~/.lamperc
	
	# load user defaults from light-settings
	if [[ -f ~/.config/lampe/light-settings ]] ; then
		source ~/.config/lampe/light-settings
	fi
	
	# receive light states
	hbReceiveLightStates

	startLampe "$@"
else
	# first start: ask user what to do
	echo " $(lColor ltyellow)?$(lColor off) [======---$(lColor ltwhite)LAMPE$(lColor off)------------------------------------]"
	echo "    You are running 'lampe' for the first time. Do you "
	echo -n "    wish automatic discovery and configuration? [$(lColor ltwhite)y$(lColor off)/$(lColor ltred)n$(lColor off)] "
	read doIt
	if [[ "$doIt" == "y" ]] || [[ "$doIt" == "Y" ]] || [[ "$doIt" == "" ]] ; then
		hbDetect 2> /dev/null
		if [ "$_BRIDGE_FOUND" == false ] ; then
			echo " $(lColor ltred)?$(lColor off)  warning, unable to find bridge"
			hbEnterIP
		fi
	else 
		hbEnterIP
	fi
	
	if [[ "$_BRIDGE_FOUND" == true ]] ; then
		# register a user at bridge
		hbRegisterUser
		
		# store configuration if bridge was found
		echo "bridgeip=\"$bridgeip\"" > ~/.lamperc
		
		# receive light states
		hbReceiveLightStates
		
		startLampe "$@"
	else
		echo " $(lColor ltred)!$(lColor off)  no bridge found, error 2"
		exit 2
	fi
fi

